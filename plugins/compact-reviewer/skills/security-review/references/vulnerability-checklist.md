# Security Vulnerability Checklist

Comprehensive checklist for Compact smart contract security review.

## Access Control Vulnerabilities

### AC-01: Missing Authorization on Exported Circuits

**Severity**: üî¥ Critical

**Description**: Exported circuits callable by anyone without verification.

**Detection**:
```
For each `export circuit`:
  - Does it modify ledger state?
  - Is there a witness-based authorization check?
  - Is the check cryptographically verified (hash comparison)?
```

**Vulnerable Pattern**:
```compact
export circuit transfer(to: Bytes<32>, amount: Uint<64>): [] {
    // ‚ùå No authorization check
    balances[from].decrement(amount);
    balances[to].increment(amount);
}
```

**Fixed Pattern**:
```compact
witness get_sender_secret(): Bytes<32>;

export circuit transfer(to: Bytes<32>, amount: Uint<64>): [] {
    const sender = get_sender_secret();
    const sender_addr = hash(sender);
    // ‚úÖ Cryptographic authorization
    balances[sender_addr].decrement(amount);
    balances[to].increment(amount);
}
```

### AC-02: Weak Authorization Check

**Severity**: üü† High

**Description**: Authorization exists but uses weak verification.

**Detection**:
- Check if authorization uses direct comparison vs hash comparison
- Verify secret entropy is sufficient
- Ensure timing-safe comparison

**Vulnerable Pattern**:
```compact
witness get_admin_id(): Uint<64>;

export circuit admin_action(): [] {
    // ‚ùå Weak: low-entropy, directly compared
    assert get_admin_id() == 12345;
}
```

**Fixed Pattern**:
```compact
witness get_admin_secret(): Bytes<32>;
ledger admin_hash: Cell<Bytes<32>>;

export circuit admin_action(): [] {
    // ‚úÖ High-entropy secret, hash verified
    assert hash(get_admin_secret()) == admin_hash.read();
}
```

### AC-03: Authorization Bypass via Default Values

**Severity**: üî¥ Critical

**Description**: Default or zero values allow unauthorized access.

**Detection**:
- Check for uninitialized ledger values in authorization
- Verify zero-value handling

**Vulnerable Pattern**:
```compact
ledger owner: Cell<Bytes<32>>;  // Initially zero

export circuit claim_ownership(secret: Bytes<32>): [] {
    // ‚ùå Anyone can claim if owner not set
    assert hash(secret) == owner.read() || owner.read() == ZERO;
}
```

---

## Disclosure Vulnerabilities

### DV-01: Missing disclose() on Public Outputs

**Severity**: üî¥ Critical

**Description**: Witness-derived values returned without explicit disclosure.

**Detection**:
```
For each `export circuit` return:
  - Trace value to origin
  - If origin is witness, verify disclose() is used
```

**Vulnerable Pattern**:
```compact
witness get_secret_balance(): Uint<64>;

export circuit reveal_balance(): Uint<64> {
    // ‚ùå Compilation error or privacy leak
    return get_secret_balance();
}
```

**Fixed Pattern**:
```compact
export circuit reveal_balance(): Uint<64> {
    // ‚úÖ Explicit disclosure
    return disclose(get_secret_balance());
}
```

### DV-02: Implicit Disclosure via Ledger

**Severity**: üü† High

**Description**: Witness values written to public ledger without awareness.

**Detection**:
- Track witness values written to ledger
- Verify intent is documented

**Vulnerable Pattern**:
```compact
witness get_vote(): Uint<8>;

export circuit record_vote(): [] {
    const vote = get_vote();
    // ‚ùå Vote becomes public on ledger
    votes.push(vote);
}
```

### DV-03: Taint Propagation

**Severity**: üü† High

**Description**: Witness taint flows through computations to public outputs.

**Detection**:
- Build data flow graph from witnesses
- Check if any tainted values reach public outputs

**Vulnerable Pattern**:
```compact
witness get_private_amount(): Uint<64>;

export circuit compute_fee(): Uint<64> {
    const amount = get_private_amount();
    const fee = amount / 100;  // Tainted by amount
    return disclose(fee);  // ‚ö†Ô∏è Leaks information about amount
}
```

---

## ZK-Specific Vulnerabilities

### ZK-01: Low-Entropy Nullifier Input (AV-03)

**Severity**: üî¥ Critical

**Description**: Nullifiers from low-entropy inputs can be brute-forced.

**Detection**:
- Find `persistentHash()` calls
- Check input entropy (Uint<1-20>, enums, small sets)

**Vulnerable Pattern**:
```compact
witness get_vote(): Uint<8>;  // Only 256 values

export circuit vote_nullifier(): Bytes<32> {
    // ‚ùå Attacker can precompute all 256 nullifiers
    return persistentHash("vote", get_vote() as Field);
}
```

**Fixed Pattern**:
```compact
witness get_vote(): Uint<8>;
witness get_voter_secret(): Bytes<32>;

export circuit vote_nullifier(): Bytes<32> {
    const vote = get_vote();
    const secret = get_voter_secret();
    // ‚úÖ High-entropy component prevents brute-force
    return persistentHash("vote", secret, vote as Field);
}
```

### ZK-02: Witness Entropy Exhaustion (AV-06)

**Severity**: üî¥ Critical

**Description**: Bounded witnesses allow brute-force recovery.

**Detection**:
- Check witness types: Uint<1-20>, Boolean, small enums
- Verify high-entropy mixing in security-critical operations

**Entropy Guide**:
| Type | Entropy | Risk |
|------|---------|------|
| Boolean | 1 bit | Trivial brute-force |
| Uint<8> | 8 bits | 256 attempts |
| Uint<16> | 16 bits | 65,536 attempts |
| Uint<32> | 32 bits | ~4 billion attempts |
| Bytes<32> | 256 bits | Computationally infeasible |

### ZK-03: Timing Leakage via Control Flow (AV-01)

**Severity**: üü† High

**Description**: Witness-dependent control flow leaks information through proof timing.

**Detection**:
- Find `if` statements conditioned on witness values
- Check for witness-dependent loop counts

**Vulnerable Pattern**:
```compact
witness get_balance(): Uint<64>;

export circuit process(): [] {
    const balance = get_balance();
    if disclose(balance) > 1000 {
        // ‚ùå Different execution path leaks balance range
        for i in 0..100 { expensiveOp(); }
    }
}
```

### ZK-04: Circuit Under-Constraint (AV-08)

**Severity**: üî¥ Critical

**Description**: Missing assertions allow invalid inputs to succeed.

**Detection**:
- Check all witnesses have range/validity assertions
- Verify enum witnesses checked against valid variants

**Vulnerable Pattern**:
```compact
witness get_index(): Uint<8>;

export circuit access_item(): Field {
    const idx = get_index();
    // ‚ùå No bounds check - idx could be > array length
    return items[idx].read();
}
```

**Fixed Pattern**:
```compact
export circuit access_item(): Field {
    const idx = get_index();
    assert idx < ITEM_COUNT;  // ‚úÖ Bounds enforced
    return items[idx].read();
}
```

---

## State Management Vulnerabilities

### SM-01: Read-Modify-Write Race

**Severity**: üü† High

**Description**: Non-atomic ledger operations allow race conditions.

**Detection**:
- Find read-then-write patterns on same ledger cell
- Check for time-of-check-to-time-of-use gaps

**Vulnerable Pattern**:
```compact
export circuit double_reward(): [] {
    const current = balance.read();
    // ‚ùå Another tx could modify balance here
    balance.write(current * 2);
}
```

### SM-02: Stale State Usage

**Severity**: üü° Medium

**Description**: Using outdated state without freshness verification.

**Detection**:
- Check Merkle proof freshness in multi-step operations
- Verify state timestamps where applicable

---

## Cryptographic Vulnerabilities

### CR-01: Nonce Reuse in Commitments

**Severity**: üî¥ Critical

**Description**: Reusing nonces in commitments enables linking.

**Detection**:
- Track nonce generation and usage
- Verify unique nonces per commitment

### CR-02: Weak Domain Separation

**Severity**: üü† High

**Description**: Hash collisions across different contexts.

**Detection**:
- Check hash calls include domain tag
- Verify domain tags are unique per use case

**Vulnerable Pattern**:
```compact
// ‚ùå Same hash structure for different purposes
return persistentHash(value);
```

**Fixed Pattern**:
```compact
// ‚úÖ Domain-separated hashes
return persistentHash("user-auth", value);
return persistentHash("nullifier", value);
```

---

## Checklist Summary

| Category | ID | Issue | Severity |
|----------|-----|-------|----------|
| Access Control | AC-01 | Missing authorization | üî¥ Critical |
| Access Control | AC-02 | Weak authorization | üü† High |
| Access Control | AC-03 | Authorization bypass | üî¥ Critical |
| Disclosure | DV-01 | Missing disclose() | üî¥ Critical |
| Disclosure | DV-02 | Implicit ledger disclosure | üü† High |
| Disclosure | DV-03 | Taint propagation | üü† High |
| ZK-Specific | ZK-01 | Low-entropy nullifier | üî¥ Critical |
| ZK-Specific | ZK-02 | Entropy exhaustion | üî¥ Critical |
| ZK-Specific | ZK-03 | Timing leakage | üü† High |
| ZK-Specific | ZK-04 | Under-constraint | üî¥ Critical |
| State | SM-01 | Read-modify-write race | üü† High |
| State | SM-02 | Stale state usage | üü° Medium |
| Crypto | CR-01 | Nonce reuse | üî¥ Critical |
| Crypto | CR-02 | Weak domain separation | üü† High |
