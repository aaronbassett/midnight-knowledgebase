/**
 * Reading Ledger State Example
 *
 * This file demonstrates reading on-chain state from Midnight Compact contracts,
 * including simple values, ADT collections, and real-time subscriptions.
 *
 * Corresponding Compact contract (registry.compact):
 * ```compact
 * ledger {
 *     admin: Bytes<32>;
 *     total_registrations: Counter;
 *     users: Map<Bytes<32>, UserInfo>;
 *     active_sessions: Set<Bytes<32>>;
 *     commitment_tree: MerkleTree<32>;
 *     config: RegistryConfig;
 * }
 *
 * struct UserInfo {
 *     name: Opaque<'string'>,
 *     level: Uint<8>,
 *     registered_at: Uint<64>,
 *     metadata: Opaque<'string'>
 * }
 *
 * struct RegistryConfig {
 *     max_users: Uint<32>,
 *     registration_fee: Uint<128>,
 *     is_open: Boolean
 * }
 * ```
 */

// =============================================================================
// Type Definitions
// =============================================================================

/**
 * User info matching Compact struct
 */
interface UserInfo {
  name: string; // Opaque<'string'>
  level: bigint; // Uint<8>
  registered_at: bigint; // Uint<64>
  metadata: string; // Opaque<'string'>
}

/**
 * Registry configuration matching Compact struct
 */
interface RegistryConfig {
  max_users: bigint; // Uint<32>
  registration_fee: bigint; // Uint<128>
  is_open: boolean; // Boolean
}

/**
 * Contract state interface (generated by compiler)
 */
interface RegistryContractState {
  admin(): Promise<Uint8Array>;
  total_registrations(): Promise<bigint>;
  users: {
    get(key: Uint8Array): Promise<UserInfo | undefined>;
    has(key: Uint8Array): Promise<boolean>;
    entries(): AsyncIterable<[Uint8Array, UserInfo]>;
    keys(): AsyncIterable<Uint8Array>;
    values(): AsyncIterable<UserInfo>;
    size(): Promise<bigint>;
  };
  active_sessions: {
    has(key: Uint8Array): Promise<boolean>;
    entries(): AsyncIterable<Uint8Array>;
    size(): Promise<bigint>;
  };
  commitment_tree: {
    root(): Promise<Uint8Array>;
    get(index: bigint): Promise<Uint8Array | undefined>;
    size(): Promise<bigint>;
  };
  config(): Promise<RegistryConfig>;
}

/**
 * Mock contract interface
 */
interface RegistryContract {
  state: RegistryContractState;
  events: {
    on(event: string, handler: (data: unknown) => void): () => void;
  };
}

// =============================================================================
// Utility Functions
// =============================================================================

function bytesToHex(bytes: Uint8Array): string {
  return Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");
}

function hexToBytes(hex: string): Uint8Array {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(cleanHex.substr(i * 2, 2), 16);
  }
  return bytes;
}

function formatTimestamp(timestamp: bigint): string {
  return new Date(Number(timestamp) * 1000).toISOString();
}

function formatAmount(amount: bigint, decimals: number = 18): string {
  const divisor = 10n ** BigInt(decimals);
  const whole = amount / divisor;
  const fraction = amount % divisor;
  return `${whole}.${fraction.toString().padStart(decimals, "0").slice(0, 4)}`;
}

// =============================================================================
// State Reading Functions
// =============================================================================

/**
 * Read simple ledger values
 */
async function readSimpleValues(contract: RegistryContract): Promise<void> {
  console.log("Reading simple ledger values...\n");

  // Read admin address (Bytes<32>)
  const admin = await contract.state.admin();
  console.log(`Admin: ${bytesToHex(admin)}`);

  // Read counter value
  const totalRegistrations = await contract.state.total_registrations();
  console.log(`Total Registrations: ${totalRegistrations}`);

  // Read struct value
  const config = await contract.state.config();
  console.log("\nRegistry Configuration:");
  console.log(`  Max Users: ${config.max_users}`);
  console.log(`  Registration Fee: ${formatAmount(config.registration_fee)} tokens`);
  console.log(`  Is Open: ${config.is_open}`);
}

/**
 * Read from Map ADT
 */
async function readMapData(
  contract: RegistryContract,
  userAddresses: Uint8Array[]
): Promise<void> {
  console.log("\nReading user data from Map...\n");

  for (const address of userAddresses) {
    const addressHex = bytesToHex(address);

    // Check if user exists
    const exists = await contract.state.users.has(address);
    if (!exists) {
      console.log(`User ${addressHex.slice(0, 16)}... not found`);
      continue;
    }

    // Get user info
    const userInfo = await contract.state.users.get(address);
    if (userInfo) {
      console.log(`User: ${addressHex.slice(0, 16)}...`);
      console.log(`  Name: ${userInfo.name}`);
      console.log(`  Level: ${userInfo.level}`);
      console.log(`  Registered: ${formatTimestamp(userInfo.registered_at)}`);

      // Parse metadata JSON if present
      try {
        const metadata = JSON.parse(userInfo.metadata);
        console.log(`  Metadata:`, metadata);
      } catch {
        console.log(`  Metadata: ${userInfo.metadata}`);
      }
    }
  }
}

/**
 * Iterate over Map entries
 */
async function iterateAllUsers(contract: RegistryContract): Promise<void> {
  console.log("\nIterating all users...\n");

  let count = 0;
  const maxDisplay = 10;

  for await (const [address, userInfo] of contract.state.users.entries()) {
    count++;
    if (count <= maxDisplay) {
      console.log(`${count}. ${userInfo.name} (Level ${userInfo.level})`);
      console.log(`   Address: ${bytesToHex(address).slice(0, 16)}...`);
    }
  }

  if (count > maxDisplay) {
    console.log(`... and ${count - maxDisplay} more users`);
  }

  console.log(`\nTotal users found: ${count}`);
}

/**
 * Read from Set ADT
 */
async function readSetData(contract: RegistryContract): Promise<void> {
  console.log("\nReading active sessions from Set...\n");

  // Check specific session
  const testSession = new Uint8Array(32);
  crypto.getRandomValues(testSession);

  const isActive = await contract.state.active_sessions.has(testSession);
  console.log(`Test session active: ${isActive}`);

  // Get total active sessions
  const totalSessions = await contract.state.active_sessions.size();
  console.log(`Total active sessions: ${totalSessions}`);

  // Iterate sessions (limited)
  console.log("\nActive session IDs:");
  let count = 0;
  for await (const sessionId of contract.state.active_sessions.entries()) {
    count++;
    if (count <= 5) {
      console.log(`  ${bytesToHex(sessionId).slice(0, 32)}...`);
    }
  }
}

/**
 * Read from MerkleTree ADT
 */
async function readMerkleTree(contract: RegistryContract): Promise<void> {
  console.log("\nReading Merkle tree data...\n");

  // Get current root
  const root = await contract.state.commitment_tree.root();
  console.log(`Merkle Root: ${bytesToHex(root)}`);

  // Get tree size
  const size = await contract.state.commitment_tree.size();
  console.log(`Tree Size: ${size} leaves`);

  // Read specific leaf
  if (size > 0n) {
    const leaf = await contract.state.commitment_tree.get(0n);
    if (leaf) {
      console.log(`First Leaf: ${bytesToHex(leaf)}`);
    }
  }
}

/**
 * Subscribe to state changes
 */
function subscribeToEvents(contract: RegistryContract): () => void {
  console.log("\nSubscribing to contract events...\n");

  const unsubscribers: (() => void)[] = [];

  // Subscribe to registration events
  const unsubRegister = contract.events.on("UserRegistered", (event: unknown) => {
    const e = event as { address: Uint8Array; name: string };
    console.log(`[Event] New user registered: ${e.name}`);
  });
  unsubscribers.push(unsubRegister);

  // Subscribe to session events
  const unsubSession = contract.events.on("SessionStarted", (event: unknown) => {
    const e = event as { sessionId: Uint8Array; userId: Uint8Array };
    console.log(`[Event] Session started for user ${bytesToHex(e.userId).slice(0, 16)}...`);
  });
  unsubscribers.push(unsubSession);

  // Subscribe to all events
  const unsubAll = contract.events.on("*", (event: unknown) => {
    console.log(`[Event] Contract event:`, event);
  });
  unsubscribers.push(unsubAll);

  // Return cleanup function
  return () => {
    unsubscribers.forEach((unsub) => unsub());
    console.log("Unsubscribed from all events");
  };
}

/**
 * Build a state snapshot for caching or display
 */
async function buildStateSnapshot(
  contract: RegistryContract
): Promise<{
  admin: string;
  totalRegistrations: string;
  config: RegistryConfig;
  merkleRoot: string;
  activeSessionCount: string;
  topUsers: { address: string; name: string; level: string }[];
}> {
  console.log("\nBuilding state snapshot...\n");

  // Parallel reads for efficiency
  const [admin, totalRegistrations, config, merkleRoot, sessionCount] =
    await Promise.all([
      contract.state.admin(),
      contract.state.total_registrations(),
      contract.state.config(),
      contract.state.commitment_tree.root(),
      contract.state.active_sessions.size(),
    ]);

  // Collect top users (limited iteration)
  const topUsers: { address: string; name: string; level: string }[] = [];
  let count = 0;
  for await (const [address, userInfo] of contract.state.users.entries()) {
    topUsers.push({
      address: bytesToHex(address),
      name: userInfo.name,
      level: userInfo.level.toString(),
    });
    count++;
    if (count >= 10) break;
  }

  // Sort by level descending
  topUsers.sort((a, b) => Number(b.level) - Number(a.level));

  return {
    admin: bytesToHex(admin),
    totalRegistrations: totalRegistrations.toString(),
    config,
    merkleRoot: bytesToHex(merkleRoot),
    activeSessionCount: sessionCount.toString(),
    topUsers,
  };
}

// =============================================================================
// Polling and Caching Patterns
// =============================================================================

/**
 * Poll state at regular intervals
 */
function pollState(
  contract: RegistryContract,
  intervalMs: number,
  callback: (state: Awaited<ReturnType<typeof buildStateSnapshot>>) => void
): () => void {
  let running = true;

  async function poll() {
    while (running) {
      try {
        const snapshot = await buildStateSnapshot(contract);
        callback(snapshot);
      } catch (error) {
        console.error("Polling error:", error);
      }
      await new Promise((resolve) => setTimeout(resolve, intervalMs));
    }
  }

  poll();

  return () => {
    running = false;
  };
}

/**
 * Cached state reader with TTL
 */
class CachedStateReader {
  private cache = new Map<string, { value: unknown; expiry: number }>();
  private defaultTtl: number;

  constructor(
    private contract: RegistryContract,
    defaultTtlMs: number = 5000
  ) {
    this.defaultTtl = defaultTtlMs;
  }

  private async getOrFetch<T>(
    key: string,
    fetcher: () => Promise<T>,
    ttl?: number
  ): Promise<T> {
    const now = Date.now();
    const cached = this.cache.get(key);

    if (cached && cached.expiry > now) {
      return cached.value as T;
    }

    const value = await fetcher();
    this.cache.set(key, {
      value,
      expiry: now + (ttl ?? this.defaultTtl),
    });

    return value;
  }

  async getAdmin(): Promise<Uint8Array> {
    // Admin rarely changes, use longer TTL
    return this.getOrFetch("admin", () => this.contract.state.admin(), 60000);
  }

  async getConfig(): Promise<RegistryConfig> {
    return this.getOrFetch("config", () => this.contract.state.config(), 30000);
  }

  async getTotalRegistrations(): Promise<bigint> {
    // Counter changes frequently, use short TTL
    return this.getOrFetch(
      "total_registrations",
      () => this.contract.state.total_registrations(),
      1000
    );
  }

  async getUserInfo(address: Uint8Array): Promise<UserInfo | undefined> {
    const key = `user:${bytesToHex(address)}`;
    return this.getOrFetch(key, () => this.contract.state.users.get(address));
  }

  invalidate(key?: string): void {
    if (key) {
      this.cache.delete(key);
    } else {
      this.cache.clear();
    }
  }
}

// =============================================================================
// Main Example
// =============================================================================

async function main() {
  console.log("=".repeat(60));
  console.log("Midnight Contract State Reading Examples");
  console.log("=".repeat(60));

  // Mock contract (replace with actual contract connection)
  // import { createRegistryContract } from './build/registry';
  // import { MidnightProvider } from '@midnight-ntwrk/midnight-js-provider';
  //
  // const provider = new MidnightProvider({
  //   networkId: 'testnet',
  //   nodeUrl: 'https://rpc.testnet.midnight.network'
  // });
  // const contract = createRegistryContract(provider, contractAddress);

  // Create mock contract for demonstration
  const mockContract = createMockContract();

  // Read simple values
  await readSimpleValues(mockContract);

  // Read map data
  const testAddresses = [new Uint8Array(32), new Uint8Array(32)];
  crypto.getRandomValues(testAddresses[0]);
  crypto.getRandomValues(testAddresses[1]);
  await readMapData(mockContract, testAddresses);

  // Iterate all users
  await iterateAllUsers(mockContract);

  // Read set data
  await readSetData(mockContract);

  // Read merkle tree
  await readMerkleTree(mockContract);

  // Build snapshot
  const snapshot = await buildStateSnapshot(mockContract);
  console.log("\nState Snapshot:");
  console.log(JSON.stringify(snapshot, null, 2));

  // Demonstrate caching
  const cachedReader = new CachedStateReader(mockContract);
  const admin1 = await cachedReader.getAdmin();
  const admin2 = await cachedReader.getAdmin(); // Returns cached
  console.log("\nCached reads return same instance:", admin1 === admin2);

  console.log("\n" + "=".repeat(60));
  console.log("State reading examples complete!");
  console.log("=".repeat(60));
}

// =============================================================================
// Mock Contract (for demonstration)
// =============================================================================

function createMockContract(): RegistryContract {
  const mockUsers = new Map<string, UserInfo>();

  // Add some mock users
  for (let i = 0; i < 5; i++) {
    const addr = new Uint8Array(32);
    crypto.getRandomValues(addr);
    mockUsers.set(bytesToHex(addr), {
      name: `User ${i + 1}`,
      level: BigInt(Math.floor(Math.random() * 10) + 1),
      registered_at: BigInt(Math.floor(Date.now() / 1000) - Math.random() * 86400 * 30),
      metadata: JSON.stringify({ verified: Math.random() > 0.5 }),
    });
  }

  return {
    state: {
      admin: async () => {
        const admin = new Uint8Array(32);
        admin.fill(1);
        return admin;
      },
      total_registrations: async () => BigInt(mockUsers.size),
      users: {
        get: async (key: Uint8Array) => mockUsers.get(bytesToHex(key)),
        has: async (key: Uint8Array) => mockUsers.has(bytesToHex(key)),
        entries: async function* () {
          for (const [key, value] of mockUsers.entries()) {
            yield [hexToBytes(key), value] as [Uint8Array, UserInfo];
          }
        },
        keys: async function* () {
          for (const key of mockUsers.keys()) {
            yield hexToBytes(key);
          }
        },
        values: async function* () {
          for (const value of mockUsers.values()) {
            yield value;
          }
        },
        size: async () => BigInt(mockUsers.size),
      },
      active_sessions: {
        has: async () => false,
        entries: async function* () {},
        size: async () => 0n,
      },
      commitment_tree: {
        root: async () => {
          const root = new Uint8Array(32);
          crypto.getRandomValues(root);
          return root;
        },
        get: async () => undefined,
        size: async () => 100n,
      },
      config: async () => ({
        max_users: 10000n,
        registration_fee: 100n * 10n ** 18n,
        is_open: true,
      }),
    },
    events: {
      on: (event: string, handler: (data: unknown) => void) => {
        console.log(`Subscribed to event: ${event}`);
        return () => console.log(`Unsubscribed from event: ${event}`);
      },
    },
  };
}

// Run if executed directly
if (require.main === module) {
  main().catch(console.error);
}

export {
  readSimpleValues,
  readMapData,
  iterateAllUsers,
  readSetData,
  readMerkleTree,
  buildStateSnapshot,
  pollState,
  CachedStateReader,
  UserInfo,
  RegistryConfig,
};
